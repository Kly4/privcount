#!/usr/bin/env python
'''
Created on Dec 12, 2015

@author: rob
'''
import sys
import argparse
from time import time

from twisted.internet import reactor
from twisted.internet.protocol import ClientFactory
from twisted.protocols.basic import LineOnlyReceiver

class PrivCountDataInjector(LineOnlyReceiver):

    def __init__(self, factory, logpath, do_pause, prune_before, prune_after):
        self.factory = factory
        self.logpath = logpath
        self.do_pause = do_pause
        self.prune_before = prune_before
        self.prune_after = prune_after
        loc = sys.stdin if self.logpath == '-' else self.logpath
        self.event_file = open(loc, 'r')
        self.last_time_end = 0.0

    def get_line(self):
        if self.event_file == None:
            return None
        line = self.event_file.readline()
        if line == '':
            self.event_file.close()
            self.event_file = None
            return None
        else:
            return line

    def flush_now(self, msg):
        # update event times so the data seems fresh to privcount
        this_time_start, this_time_end = self._get_event_times(msg)
        now = time()
        alive = this_time_end - this_time_start
        msg_adjusted_times = self._set_event_times(msg, now-alive, now)
        print "sending event '{}'".format(msg_adjusted_times)
        self.sendLine(msg_adjusted_times)

    def flush_later(self, msg):
        self.flush_now(msg)
        self.inject_events()

    def inject_events(self):
        while True:
            line = self.get_line()
            if line is None:
                self.transport.loseConnection()
                return

            msg = line.strip()
            this_time_start, this_time_end = self._get_event_times(msg)

            # make sure this event is in our 'valid' event window
            if this_time_end < self.prune_before or this_time_end > self.prune_after:
                continue

            # if we need to simulate event inter-arrival times
            do_wait, wait_time = False, 0.0
            if self.do_pause:
                wait_time = this_time_end - self.last_time_end
                do_wait = True if self.last_time_end != 0.0 and wait_time > 0.0 else False
                self.last_time_end = this_time_end

            if do_wait:
                # we cant sleep or twisted wont work correctly, we must use callLater instead
                reactor.callLater(wait_time, self.flush_later, msg) # pylint: disable=E1101
                return
            else:
                self.flush_now(msg)

    def connectionMade(self):
        print "Injecting data"
        loc = sys.stdin if self.logpath == '-' else self.logpath

        if self.do_pause:
            print "We will pause between the injection of each event to simulate actual event inter-arrival times, so this may take a while"

        self.inject_events()

    def _get_event_times(self, msg):
        parts = msg.split()
        if parts[0] == 'c' and len(parts) > 10:
            return float(parts[9]), float(parts[10])
        elif parts[0] == 's' and len(parts) > 8:
            return float(parts[7]), float(parts[8])
        elif parts[0] == 't' and len(parts) > 3:
            return float(parts[2]), float(parts[3])
        return 0.0, 0.0

    def _set_event_times(self, msg, start_time, end_time):
        parts = msg.split()
        if parts[0] == 'c' and len(parts) > 10:
            parts[9], parts[10] = start_time, end_time
        elif parts[0] == 's' and len(parts) > 8:
            parts[7], parts[8] = start_time, end_time
        elif parts[0] == 't' and len(parts) > 3:
            parts[2], parts[3] = start_time, end_time
        return ' '.join([str(p) for p in parts])

class PrivCountDataInjectorFactory(ClientFactory):
    protocol = PrivCountDataInjector # not really needed, since we build our own protocol below

    def __init__(self, logpath, do_pause, prune_before, prune_after):
        self.logpath = logpath
        self.do_pause = do_pause
        self.prune_before = prune_before
        self.prune_after = prune_after

    def buildProtocol(self, addr):
        return PrivCountDataInjector(self, self.logpath, self.do_pause, self.prune_before, self.prune_after)

    def clientConnectionFailed(self, connector, reason):
        print "Connection to DC failed - goodbye!"
        reactor.stop() # pylint: disable=E1101

    def clientConnectionLost(self, connector, reason):
        print "Connection to DC lost - goodbye!"
        reactor.stop() # pylint: disable=E1101

def main():
    ap = argparse.ArgumentParser(description="Injects Tor events into a listening PrivCount DC")
    ap.add_argument('-p', '--port', help="port of PrivCount DC to inject data to", required=True)
    ap.add_argument('-l', '--log', help="a file PATH to a PrivCount event log file, may be '-' for STDIN", required=True, default='-')
    ap.add_argument('-s', '--simulate', action='store_true', help="add pauses between each event injection to simulate the inter-arrival times from the source data")
    ap.add_argument('--prune-before', help="do not inject events that occurred before the given unix timestamp", default=0)
    ap.add_argument('--prune-after', help="do not inject events that occurred after the given unix timestamp", default=2147483647)
    args = ap.parse_args()

    # pylint: disable=E1101
    reactor.connectTCP("127.0.0.1", int(args.port), PrivCountDataInjectorFactory(args.log, args.simulate, int(args.prune_before), int(args.prune_after)))
    reactor.run()

if __name__ == "__main__":
    sys.exit(main())
